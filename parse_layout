#!/usr/bin/env python3
# vim: tabstop=4 expandtab

import sys
import re

from os import SEEK_CUR, path
from xml.dom import minidom
from xml.dom.minidom import Node
from cgi import escape

def cwrite( str ):
    C_FILE.write( bytearray( str, 'utf-8' ) )

LAYOUT = sys.argv[1]
LAYOUT = path.basename( LAYOUT )

if LAYOUT.endswith( '.xml' ):
    LAYOUT = LAYOUT[:-4]

TREE = minidom.parse( 'layouts/{}.xml'.format( LAYOUT ) )

H_FILE = open( 'include/gen/layouts/{}.h'.format( LAYOUT ), 'w' )

H_FILE.write( '#ifndef LAYOUT_{}_H\n'.format( LAYOUT ) )
H_FILE.write( '#define LAYOUT_{}_H\n\n'.format( LAYOUT ) )
H_FILE.write( '#include "xml/node.h"\n\n' )
H_FILE.write( 'extern const union html_node {};\n\n'.format( LAYOUT ) )

C_FILE = open( 'gen/layouts/{}.c'.format( LAYOUT ), 'w+b' )
cwrite( '#include "gen/layouts/{}.h"\n'.format( LAYOUT ) )
cwrite( '#include "layout.h"\n\n' )
cwrite( 'const union html_node {} =\n'.format( LAYOUT ) )

TOKENS = {}

def create_node( node, depth ):
    if node.nodeType == Node.ELEMENT_NODE:
        return create_element( node, depth )
    elif node.nodeType == Node.TEXT_NODE:
        return create_text( node, depth )
    elif node.nodeType == Node.CDATA_SECTION_NODE:
        return create_text( node, depth )
    else:
        cwrite( '/* {} */'.format( Node ) )
        return False

def create_cdata( text, depth ):
    cwrite( '\t' * depth )
    cwrite( 'text(\n' )
    cwrite( '"{}"\n'.format( escape( text.data ) ) )
    cwrite( '\t' * depth )
    cwrite( ')\n' )

def create_text( text, depth ):
    if text.data.strip() == "":
        return False

    cwrite( '\t' * depth )

    if text.data[0] == '$':
        text.data = text.data[1:]
        TOKENS[text.data] = 1
        cwrite( 'replace( ' )
        cwrite( text.data )
    else:
        text.data = re.sub( r"\s+", " ", text.data )
        cwrite( 'text( "{}"'.format( escape( text.data ) ) )

    cwrite( ' )\n' )
    return True

def create_element( element, depth ):
    if element.tagName == '_var':
        return create_text( element.firstChild, depth )

    cwrite( '\t' * depth )
    cwrite( 'element(\n' )
    cwrite( '\t' * ( depth + 1 ) )
    cwrite( '"{}",\n'.format( element.tagName ) )
    cwrite( '\t' * ( depth + 1 ) )

    attrs = element.attributes

    if attrs:
        cwrite( 'attrs( ' )
        for key in attrs.keys():
            val = element.getAttribute( key )
            if val[0] == '$':
                TOKENS[val[1:]] = 1;
                cwrite( "at_rep( \"{}\", {} ), ".format( key, val[1:] ) )
            else:
                cwrite( "at_str( \"{}\", \"{}\" ), ".format( key, val ) )

        C_FILE.seek( -2, SEEK_CUR )
        cwrite( ' ),\n' )
    else:
        cwrite( 'NULL,\n' )

    cwrite( '\t' * ( depth + 1 ) )

    if element.hasChildNodes():
        cwrite( 'children(\n' )

        for child in element.childNodes:
            if create_node( child, depth + 2 ):
                C_FILE.seek( -1, SEEK_CUR )
                cwrite( ',\n' )

        C_FILE.seek( -2, SEEK_CUR )
        cwrite( '\n' )
        cwrite( '\t' * ( depth + 1 ) )
        cwrite( ')\n' )
    else:
        cwrite( 'NULL\n' )

    cwrite( '\t' * depth )
    cwrite( ')\n' )
    return True

create_node( TREE.documentElement, 0 )

cwrite( ';\n' )

H_FILE.write( 'enum {}_replacements\n{}\n'.format( LAYOUT, '{' ) )

for token in TOKENS:
    H_FILE.write( '\t{},\n'.format( token ) )

H_FILE.write( '\t__MAX\n};\n\n#endif\n' )

#close( C_FILE )
#close( H_FILE )
