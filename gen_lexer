#!/usr/bin/python3
# vim: tabstop=4 expandtab nospell

import sys
from string import ascii_letters

ascii_and_null = set( ascii_letters ).union( set('\0') )

def add_token( node, token, fulltoken ):
    if len( token ) == 0:
        node[ '\0' ] = fulltoken
        return

    if not token[0] in node:
        node[ token[0] ] = {}

    add_token( node[token[0]], token[1:], fulltoken )

def print_token_read( indent, token, char, c_file ):
    c_file.write( '\n' + '\t' * indent + 'str += ' + str(char) + ';\n' )
    c_file.write( '\n' + '\t' * indent + 'while ( str[0] == \' \' ) ++str;\n' )
    c_file.write( '\n' + '\t' * indent + 'out->' + token + ' = str;\n' )

    return True

def print_tree( node, indent, char, c_file ):
    if len( node ) == 1:
        for i in sorted( node.keys() ):
            if i == '\0':
                return print_token_read( indent, node[i], char, c_file )

            elif ( i in ascii_letters ):
                c_file.write( '\t' * indent + 'if ( ( str[' + str(char) + '] & 0xDF ) != \'' + i.upper() + '\' )\n' )

            else:
                c_file.write( '\t' * indent + 'if ( str[' + str(char) + '] != \'' + i + '\' )\n' )

            c_file.write( '\t' * indent + '{\n' )
            c_file.write( '\t' * (indent+1) + 'str += ' + str(char) + ';\n' )
            c_file.write( '\t' * (indent+1) + 'goto cleanup;\n' )
            c_file.write( '\t' * indent + '}\n' )

            print_tree( node[i], indent, char + 1, c_file );
            return

    case = set( node.keys() ).issubset( ascii_and_null )

    if case:
        c_file.write( '\n' + '\t' * indent + 'switch ( str[' + str(char) + '] & 0xDF )\n' )
    else:
        c_file.write( '\n' + '\t' * indent + 'switch ( str[' + str(char) + '] )\n' )

    c_file.write( '\t' * indent + '{\n' )

    for i in sorted( node.keys() ):
        if i == '\0':
            c_file.write( '\t' * (indent + 1) + 'case \'\\0\':\n' )
            print_token_read( indent + 2, node[i], char, c_file )

        else:
            c_file.write( '\t' * (indent + 1) + 'case \'' + i.upper() + '\':\n' )
            if not case and i.lower() != i.upper():
                c_file.write( '\t' * (indent + 1) + 'case \'' + i.lower() + '\':\n' )
            print_tree( node[i], indent + 2, char + 1, c_file )

        c_file.write( '\t' * (indent + 2) + 'break;\n\n' )

    c_file.write( '\t' * (indent + 1) + 'default:\n' )
    c_file.write( '\t' * (indent + 2) + 'goto cleanup;\n' )
    c_file.write( '\t' * indent + '}\n' )

    c_file.write( '\n' )

def gen( name ):
    tree = {}
    h_file = open( 'gen/' + name + '.h', 'w' )
    c_file = open( 'gen/' + name + '.c', 'w' )

    with open( name + '.fl', 'rU' ) as f:
        sep  = f.readline().strip()
        term = f.readline().strip()

        h_file.write( 'struct ' + 'lexed_' + name + '\n{\n' )

        for line in f:
            if line.strip():
                h_file.write( '\tconst char * ' + line.strip().replace( '-', '_' ) + ';\n' )
                add_token( tree, line.strip() + sep, line.strip().replace( '-', '_' ) )

        h_file.write( '};\n\n' )
        h_file.write( 'void lex_' + name + '( char * restrict str, struct lexed_' + name + ' * restrict out );\n' )

    h_file.close()

    c_file.write( '#include "' + name + '.h"\n' )
    c_file.write( '#include <string.h>\n\n' )
    c_file.write( 'void lex_' + name + '( char * restrict str, struct lexed_' + name + ' * restrict out )\n{\n' )
    c_file.write( '\tmemset( out, 0, sizeof( struct lexed_' + name + ' ) );\n\n' )
    c_file.write( '\twhile ( 1 )\n\t{' )
    print_tree( tree, 2, c_file )
    c_file.write( 'cleanup:' )
    c_file.write( '\n\t\twhile ( 1 )\n\t\t{\n' )
    c_file.write( '\t\t\tif ( *str == 0 )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n' )
    c_file.write( '\n\t\t\tif ( *str == \'' + term + '\' )\n\t\t\t{\n\t\t\t\tstr[0] = 0;\n\t\t\t\t++str;\n\t\t\t\tbreak;\n\t\t\t}\n' )
    if term == "\\n":
        c_file.write( '\n\t\t\tif ( *str == \'\\r\' && str[1] == \'\\n\' )\n\t\t\t{\n\t\t\t\tstr[0] = 0;\n\t\t\t\tstr[1] = 0;\n\t\t\t\tstr += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++str;\n' )

    c_file.write( '\t\t}\n\t}\n}\n' )
    c_file.close()

if __name__ == '__main__':
    gen( 'headers' )
