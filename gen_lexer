#!/usr/bin/python3
# vim: tabstop=4 expandtab nospell

import sys
from string import ascii_letters
from typing import IO

ascii_and_null = set( ascii_letters ).union( set('\0') )

def add_token( node, token, fulltoken ):
    if len( token ) == 0:
        node[ '\0' ] = fulltoken
        return

    if not token[0] in node:
        node[ token[0] ] = {}

    add_token( node[token[0]], token[1:], fulltoken )

def print_token_read( indent, token, char, c_file ):
    c_file.write( '\n' + '\t' * indent + 'str += ' + str(char) + ';\n' )
    c_file.write( '\n' + '\t' * indent + 'while ( str[0] == \' \' ) ++str;\n' )
    c_file.write( '\n' + '\t' * indent + 'out->' + token + ' = str;\n' )

    return True

def print_tree( node, indent, char, c_file ):
    if len( node ) == 1:
        for i in sorted( node.keys() ):
            if i == '\0':
                return print_token_read( indent, node[i], char, c_file )

            elif ( i in ascii_letters ):
                c_file.write( '\t' * indent + 'if ( ( str[' + str(char) + '] & 0xDF ) != \'' + i.upper() + '\' )\n' )

            else:
                c_file.write( '\t' * indent + 'if ( str[' + str(char) + '] != \'' + i + '\' )\n' )

            c_file.write( '\t' * indent + '{\n' )
            c_file.write( '\t' * (indent+1) + 'str += ' + str(char) + ';\n' )
            c_file.write( '\t' * (indent+1) + 'goto cleanup;\n' )
            c_file.write( '\t' * indent + '}\n' )

            print_tree( node[i], indent, char + 1, c_file );
            return

    case = set( node.keys() ).issubset( ascii_and_null )

    if case:
        c_file.write( '\n' + '\t' * indent + 'switch ( str[' + str(char) + '] & 0xDF )\n' )
    else:
        c_file.write( '\n' + '\t' * indent + 'switch ( str[' + str(char) + '] )\n' )

    c_file.write( '\t' * indent + '{\n' )

    for i in sorted( node.keys() ):
        if i == '\0':
            c_file.write( '\t' * (indent + 1) + 'case \'\\0\':\n' )
            print_token_read( indent + 2, node[i], char, c_file )

        else:
            c_file.write( '\t' * (indent + 1) + 'case \'' + i.upper() + '\':\n' )
            if not case and i.lower() != i.upper():
                c_file.write( '\t' * (indent + 1) + 'case \'' + i.lower() + '\':\n' )
            print_tree( node[i], indent + 2, char + 1, c_file )

        c_file.write( '\t' * (indent + 2) + 'break;\n\n' )

    c_file.write( '\t' * (indent + 1) + 'default:\n' )
    c_file.write( '\t' * (indent + 2) + 'goto cleanup;\n' )
    c_file.write( '\t' * indent + '}\n' )

    c_file.write( '\n' )

def gen( name ):
    tree = {}
    h_file = open( 'gen/' + name + '.h', 'w' )
    c_file = open( 'gen/' + name + '.c', 'w' )

    with open( name + '.fl', 'rU' ) as f:
        sep  = f.readline().strip()
        term = f.readline().strip()

        h_file.write( 'struct ' + 'lexed_' + name + '\n{\n' )

        for line in f:
            if line.strip():
                h_file.write( '\tconst char * ' + line.strip().replace( '-', '_' ) + ';\n' )
                add_token( tree, line.strip() + sep, line.strip().replace( '-', '_' ) )

        h_file.write( '};\n\n' )
        h_file.write( 'void lex_' + name + '( char * restrict str, struct lexed_' + name + ' * restrict out );\n' )

    h_file.close()

    w( c_file, 0, '#include "' + name + '.h"', '#include <string.h>', '' )
    w( c_file, 0, 'void lex_' + name + '( char * restrict str, struct lexed_' + name + ' * restrict out )', '{' )

    w( c_file, 1, 'memset( out, 0, sizeof( struct lexed_' + name + ' ) );' )

    w( c_file, 0, '' )
    w( c_file, 1, 'while ( 1 )', '{' )

    print_tree( tree, 2, 0, c_file )

    w( c_file, 0, '', 'cleanup:' )
    w( c_file, 2, 'while ( 1 )', '{' )
    w( c_file, 3,   'if ( str[0] == 0 )', '{' )
    w( c_file, 4,       'return;' )
    w( c_file, 3,   '}', 'if ( str[0] == \'' + term + '\' )', '{' )
    w( c_file, 4,       'str[0] = 0;', '++str;', 'break;' )
    w( c_file, 3,   '}' )

    if term == "\\n":
        w( c_file, 3, 'if ( str[0] == \'\\r\' && str[1] == \'\\n\' )', '{' )
        w( c_file, 4, 'str[0] = 0;', 'str[1] = 0;', 'str += 2;', 'break;' )
        w( c_file, 3, '}' )

    w( c_file, 3, '', '++str;' )

    w( c_file, 2, '}' )
    w( c_file, 1, '}' )
    w( c_file, 0, '}' )

    c_file.close()


def w( file: IO, indent: int, *data: str ):
    for line in data:
        file.write( '\t' * indent + line + '\n' )


if __name__ == '__main__':
    gen( 'headers' )
